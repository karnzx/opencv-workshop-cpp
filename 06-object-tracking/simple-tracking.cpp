#include "opencv2/opencv.hpp"

#include <iostream>
#include <sstream>

using namespace cv;
using namespace std;

class TrackObject
{
public:
    int id;
    int life;
    bool counted = false;
    vector<Point> centroids;
    Rect boundRect;

    double findDistance(Point c1, Point c2)
    {
        return sqrt(pow(c2.x - c1.x, 2) + pow(c2.y - c1.y, 2));
    }
    bool isOverlap(Point l1, Point r1, Point l2, Point r2)
    {
        // if rectangle has area 0, no overlap
        if (l1.x == r1.x || l1.y == r1.y || r2.x == l2.x || l2.y == r2.y)
            return false;

        // If one rectangle is on left side of other
        if (l1.x > r2.x || l2.x > r1.x)
            return false;

        // If one rectangle is above other
        if (r1.y < l2.y || r2.y < l1.y)
            return false;

        return true;
    }
};

double getAverage(std::vector<int> const v)
{
    if (v.empty())
    {
        return 0;
    }
    double sum = 0.0;
    for (const int i : v)
    {
        sum += (double)i;
    }
    return sum / v.size();
}

// **********************************
// Simple tracking and count object (up & down)
// run with "video.avi"
//
int main(int argc, char **argv)
{
    Mat fgMaskMOG2;                  // fg mask fg mask generated by MOG2 method
    Ptr<BackgroundSubtractor> pMOG2; // MOG2 Background subtractor
    vector<vector<Point>> contours;
    vector<Vec4i> hierarchy;
    vector<TrackObject> trackObjects;
    int objId = 0;
    int totalUp = 0;
    int totalDown = 0;
    // Threshold
    const Point LINETL = Point(0, 330);
    const Point LINEBR = Point(390, 340);
    const int MIN_DISTANCE = 125;   // min distance to know its same object
    const int MIN_RECT_SIZE = 1500; // min object to detect
    const int MAX_OBJECT_LIFE = 3;

    Rect lineRect = Rect(LINETL, LINEBR);

    VideoCapture cap(argv[1]); // open the video from args 1
    if (!cap.isOpened())       // check if we succeeded
        return -1;

    // create Background Subtractor objects
    pMOG2 = createBackgroundSubtractorMOG2(); // MOG2 approach

    namedWindow("frame", 1);
    namedWindow("FG Mask MOG 2");
    for (;;)
    {
        Mat frame;
        cap >> frame; // get a new frame from camera
        Mat canny_output;
        vector<TrackObject> currentFrameObjects; // objects in current frame
        pMOG2->apply(frame, fgMaskMOG2);

        threshold(fgMaskMOG2, fgMaskMOG2, 200, 255, THRESH_BINARY);
        morphologyEx(fgMaskMOG2, fgMaskMOG2, MORPH_OPEN, getStructuringElement(MORPH_RECT, Size(21, 21)));
        imshow("FG Mask MOG 2", fgMaskMOG2);

        findContours(fgMaskMOG2, contours, hierarchy, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);

        // contour to object list in current frame
        for (int i = 0; i < contours.size(); i++)
        {
            Point centerObj;
            vector<Point> contours_poly;
            Rect boundRect;
            approxPolyDP(contours[i], contours_poly, 5, true);
            boundRect = boundingRect(Mat(contours_poly));
            centerObj.x = boundRect.x + boundRect.width / 2;
            centerObj.y = boundRect.y + boundRect.height / 2;
            if ((boundRect.width * boundRect.height) > MIN_RECT_SIZE)
            {
                TrackObject obj;
                obj.centroids.push_back(centerObj);
                obj.boundRect = boundRect;
                currentFrameObjects.push_back(obj);
            }
        }
        // track each object
        for (int i = 0; i < currentFrameObjects.size(); i++)
        {
            double min_dist = INT_MAX;
            int min_idx = -1;
            for (int j = 0; j < trackObjects.size(); j++)
            {
                if (trackObjects[j].life > 0)
                {
                    // find distance between centroid of objects
                    double dist = trackObjects[j].findDistance(currentFrameObjects[i].centroids.back(), trackObjects[j].centroids.back());
                    if (dist < min_dist)
                    {
                        min_dist = dist;
                        min_idx = j;
                    }
                }
            }
            if (min_dist > MIN_DISTANCE) // threshold for create new obj
            {
                min_idx = -1;
            }
            // 1. new object
            if (min_idx < 0)
            {
                currentFrameObjects[i].life = MAX_OBJECT_LIFE;
                currentFrameObjects[i].id = objId++;
                trackObjects.push_back(currentFrameObjects[i]);
            }
            // 2. update object
            else
            {
                trackObjects[min_idx].life = MAX_OBJECT_LIFE;
                trackObjects[min_idx].centroids.push_back(currentFrameObjects[i].centroids.back());
                trackObjects[min_idx].boundRect = currentFrameObjects[i].boundRect;
            }
        }
        // 3. delete object
        for (int i = 0; i < trackObjects.size(); i++)
        {
            trackObjects[i].life--;
            if (trackObjects[i].life < 0)
            {
                trackObjects.erase(trackObjects.begin() + i);
            }
        }

        // display
        Mat contoursFrame = Mat::zeros(fgMaskMOG2.size(), CV_8UC3);
        for (int i = 0; i < contours.size(); i++)
            drawContours(contoursFrame, contours, (int)i, Scalar(0, 200, 0), 2, LINE_8, hierarchy, 0);

        for (int i = 0; i < trackObjects.size(); i++)
        {
            TrackObject object = trackObjects[i];
            Rect objectRect = object.boundRect;
            int centerX = object.centroids.back().x;
            int centerY = object.centroids.back().y;

            rectangle(frame, objectRect.tl(), objectRect.br(), Scalar(0, 0, 200), 2, LINE_8, 0);
            putText(frame, to_string(object.id), Point(centerX, centerY), FONT_HERSHEY_DUPLEX, 1.0, CV_RGB(118, 185, 0), 2);

            if (!object.counted && object.isOverlap(lineRect.tl(), lineRect.br(), objectRect.tl(), objectRect.br()))
            {
                vector<int> previousCentroidY;
                for (int j = 0; j < object.centroids.size() - 1; j++)
                {
                    previousCentroidY.push_back(object.centroids[j].y);
                }
                // subtract current point y with average of all previous point y
                // if number is positive object go down else is go up
                double direction = object.centroids.back().y - getAverage(previousCentroidY);
                if (direction > 0)
                {
                    totalDown += 1;
                }
                else
                {
                    totalUp += 1;
                }
                trackObjects[i].counted = true;
            }
        }

        putText(frame, "totalUp: " + to_string(totalUp), Point(lineRect.tl().x, lineRect.tl().y + 35), FONT_HERSHEY_SIMPLEX, 0.7, Scalar(0, 50, 255), 2);
        putText(frame, "totalDown: " + to_string(totalDown), Point(lineRect.tl().x, lineRect.tl().y + 65), FONT_HERSHEY_SIMPLEX, 0.7, Scalar(50, 255, 50), 2);
        rectangle(frame, lineRect.tl(), lineRect.br(), Scalar(0, 200, 200), 3, LINE_8, 0);

        imshow("Contours", contoursFrame);
        imshow("frame", frame);

        if (waitKey(30) >= 0)
            break;
    }
    return 0;
}
